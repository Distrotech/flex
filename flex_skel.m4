m4_divert(-1)
# -*-C-*- vim:set ft=cxxm4:set noexpandtab cindent:
m4_dnl This skeleton requires gnu m4 for the m4_ prefix option, and the patsubst and regex commands.
m4_ifdef(`__gnu__',,`m4_errprint(Flex requires GNU M4. Set the PATH or set the M4 environment variable to its path name.) m4_m4exit(2)')
m4_changequote
m4_changequote([[,]])
####################################################################
# All generate macros for the m4 stage contain the text "m4" or "M4"
# in them, to distinguish them from CPP macros.
#
#   m4_if_reentrant([[]])            - evaluate for reentrant scanners.
#   m4_if_not_reentrant([[]])        - evaluate for non-reentrant scanners.
#   m4_if_tables_serialization([[]]) - evaluate for external tables
#   m4_if_cxx_only([[]])             - evaluate for C++ class scanner
#   m4_if_c_only([[]])               - evaluate for C, reentrant or non-reentrant
#   m4_if_cxx_or_reentrant([[]])     - eval for C++ class or reentrant C
#   m4_if_cxx_or_not_reentrant([[]]) - eval for C++ class or non-reentrant C
#   m4_if_cxx_streamio([[]])         - eval for C++ streamio, which man be enabled
#                                      for any of the three scanner types.
#   ... more macros are defined ...
#
#   %%  -  A stop-point, where code is inserted by flex.
#          Each stop-point is numbered here and also in the code generator.
#          (See gen.c, etc. for details.)
#
##########################################################################
# Sections containing user-defined code must be quoted to prevent m4
# processing of user code. They already contain code with quote-escapes
# inserted by the flex input scanner, and just need te outer quotes here.
###########################################################################
%% M4 DEFINES
# Include standard macros (including conditionals listed above)
m4_include(M4_FLEX_INCLUDE/flex_header.m4)

m4_flex_include([[flex_code_macros.m4]])

m4_flex_include([[flex_globals.m4]])

m4_dnl The generated main() does not use yywrap().
m4_ifdef( [[M4_YY_MAIN]], [[
    m4_define([[M4_YY_SKIP_YYWRAP]])
]])

######################## BEGIN OUTPUT #############################
m4_changecom
m4_divert(0)

m4_ifdef( [[M4_YY_IN_HEADER]],[[
#ifndef M4_YY_PREFIX()FLEX_HEADER_H
#define M4_YY_PREFIX()FLEX_HEADER_H
#define M4_YY_PREFIX()IN_HEADER 1
]],[[
    m4_ifdef( [[M4_FLEX_DEBUG]],
    [[
	m4_flex_include([[flex_print_m4_params.m4]])
    ]])
    m4_ifdef( [[M4_YY_INCLUDE_HEADER]],
    [[
#include "M4_YY_HEADER_FILENAME"
	m4_divert(-1)
    ]],
    [[
#ifndef M4_YY_PREFIX()FLEX_HEADER_H
    ]])
]])
/* A lexical scanner generated by flex */
[[
%% USER TOP CODE -- %top{ ... }  OR  %header{ ... %}
]]m4_changequote(-=<{,}>=-)m4_dnl
%% USER PREDEFINES
-=<{}>=-m4_changequote([[,]])
M4_LINE_DIRECTIVE()

m4_ifdef( [[M4_YY_IN_HEADER]],,
[[[[
%% USER CODE SECTION 1
]]M4_LINE_DIRECTIVE()]])

/* begin standard C headers. */
m4_if_cxx_streamio(,[[
#include <stdio.h>
]])
m4_if_c_only([[
#include <string.h>
#include <stdlib.h>
]],
[[
#include <stdlib.h> /* C memory allocation is used in the C++ class */
]])
#include <errno.h>
m4_if_tables_serialization([[
/* These are for ntohs() and ntohl(), used for serialized tables: */
#include <sys/types.h>
#include <netinet/in.h>
]])
/* end standard C headers. */

/* begin standard C++ headers. */
m4_if_cxx_streamio([[
#include <iostream>
]],
[[
    m4_if_cxx_only([[
#include <cstdio>
    ]])
]])
m4_if_cxx_only([[
#include <cstring>
#include <cstdlib>
]])
/* end standard C++ headers. */

/* begin "flexint.h" */
m4_flex_include([[flexint.h]])[[]]
/* end "flexint.h" */

m4_if_c_only([[
m4_ifdef([[M4_YY_NAMESPACE]],[[
namespace M4_YY_NAMESPACE() {
]])
m4_flex_include([[flex_public_header.m4]])
m4_ifdef([[M4_YY_NO_EXTERN_C]],,[[
#ifdef __cplusplus
extern "C" {
#endif
]])
m4_flex_include([[flex_public_typedefs.m4]])
m4_if_not_reentrant([[
/************************************************************/
/* Declaration of public globals */
M4_PUBLIC_GLOBALS()
]])
m4_flex_include([[flex_public_protos.m4]])
m4_ifdef([[M4_YY_NO_EXTERN_C]],,[[
#ifdef __cplusplus
} /* end extern "C" */
#endif
]])
m4_ifdef([[M4_YY_NAMESPACE]],[[
} /* end namespace M4_YY_NAMESPACE() */
]])
]],
[[
/************************************************************/
/* These defines prevent inclusion of the previous "FlexLexer.h" by user code. */
#define yyFlexLexerOnce
#define __FLEX_LEXER_H

#ifndef YYLEX_BASE_CLASS_DEFINED
#define YYLEX_BASE_CLASS_DEFINED

m4_flex_include([[flex_public_header.m4]])

/* pure-virtual base class */
class M4_YY_LEX_BASE_CLASS {
public:
m4_flex_include([[flex_public_typedefs.m4]])

protected: /*FIXME protected: */
m4_flex_include([[flex_private_typedefs.m4]])

public:
/* Note: no destructor defined */
	virtual ~M4_YY_LEX_BASE_CLASS()(void) { };

	virtual void switch_to_buffer(YY_BUFFER_STATE new_buffer ) = 0;
	virtual YY_BUFFER_STATE create_buffer(M4_INSTREAM* stream, int size ) = 0;
	virtual void delete_buffer(YY_BUFFER_STATE buffer ) = 0;
	virtual void restart(M4_INSTREAM* stream ) = 0;
	virtual int lex(void) = 0;

	// NOTE: In Flex, yytext is allowed to be modified in scanner actions.
	// This version allows read-only access for general use with the base class.
	inline const char* YYText(void) { return text; }
	inline int YYLeng(void) { return leng; }
	//inline int lineno() const { return yylineno; }
	inline int debug() const { return flex_debug; }
	inline void debug( int flag ) { flex_debug = flag; }

	// Call yylex with new input/output sources.
	inline int lex(M4_INSTREAM* new_in, M4_OUTSTREAM* new_out = NULL )
	{
		switch_streams( new_in, new_out );
		return lex();
	}

	// Switch to new input/output streams. If NULL, the stream is unchanged.
	virtual void switch_streams( M4_INSTREAM* new_in = NULL,
					M4_OUTSTREAM* new_out = NULL ) = 0;

	/************ Common state variables ************/
// These are equivalent to the public globals in the non-reentrant C scanner.

protected:

M4_PUBLIC_GLOBALS()

}; /* end M4_YY_LEX_BASE_CLASS */
#endif // YYLEX_BASE_CLASS_DEFINED

#define yyFlexLexer M4_YY_LEX_CLASS()

class M4_YY_LEX_CLASS() : public M4_YY_LEX_BASE_CLASS {
public:
m4_ifdef( [[M4_YY_NO_EXTRA]],,
[[
	/* User-defined. Not touched by flex. */
	YY_EXTRA_TYPE extra;
]])

	M4_YY_LEX_CLASS()
		(M4_INSTREAM* arg_yyin = M4_STDIN,
		 M4_OUTSTREAM* arg_yyout = M4_STDOUT);

	~M4_YY_LEX_CLASS()(void);

// C++ subclasses must have the standard lex(void) function to
// support the base class. YY_DECL may still be used to alter the
// yy[[]]lex function constructed by flex, but you then must
// provide a body for the default lex() function.
// For Bison lloc and lval, use set_lval() and set_lloc().
	int lex(void);
#ifdef YY_DECL
        YY_DECL;
#endif

m4_ifdef( [[M4_YY_SKIP_YYWRAP]],
[[
	inline int yywrap(void) const { return 1; };
]])

// Declarations for additional C++-only functions.

/* Standard YY_INPUT() */
	int LexerInput( char* buf, int max_size );

/* Standard ECHO() */
	inline int LexerOutput( const char* buf, int size )
	{
m4_if_cxx_streamio([[
/* With an error, iostream does not expose the number of bytes written,
 * so it is estimated as all-or-nothing. (Good enough for error tests.)
 */
		out->write( buf, size );
		return (out->bad() ? 0 : size);
]],
[[
		return fwrite( buf, 1, size, out );
]])
	}

	virtual void LexerError( const char* msg ) { LexerClassError(msg); }

	void switch_streams(M4_INSTREAM* new_in, M4_OUTSTREAM* new_out=0);

public:
m4_define([[yy_flex_strlen]],[[strlen]])
M4_FUNC_PROTO_NG(void, LexerClassError, const char *msg);
m4_flex_include([[flex_public_protos.m4]])

private:
M4_PRIVATE_GLOBALS()

private:
m4_dnl This strips the assignments, to give just declarations.
m4_patsubst(m4_quote(M4_GEN_DATA_TABLES),[[\s*=[^;]*;]],[[;]])

private:
m4_flex_include([[flex_private_protos.m4]])

/* This allows the class to be modified without an additional sub-class */
#ifdef YY_CLASS_USER_CODE
YY_CLASS_USER_CODE
#endif
}; /* end M4_YY_LEX_CLASS */
]])

m4_ifdef( [[M4_YY_IN_HEADER]],[[
#undef M4_YY_PREFIX()IN_HEADER
#endif /* M4_YY_PREFIX()FLEX_HEADER_H */
m4_divert(-1)
]],
[[
m4_dnl End guard macros for inlined header code.
#endif /* M4_YY_PREFIX()FLEX_HEADER_H */
m4_divert(0)
]])
m4_dnl ############ END OF PUBLIC HEADER SECTION ############

m4_flex_include([[flex_private_header.m4]])

m4_if_c_only([[
m4_ifdef([[M4_YY_NAMESPACE]],[[
namespace M4_YY_NAMESPACE() {
]])
m4_flex_include([[flex_private_typedefs.m4]])
m4_flex_include([[flex_private_protos.m4]])
]])

m4_if_cxx_or_reentrant(,[[
/****************** Define globals ******************/
M4_GLOBALS_DEF()
]])
/****************** Define Data Tables ******************/
m4_ifdef([[M4_YY_NXT_TABLE_LOLEN]],[[
#define YY_NXT_LOLEN (M4_YY_NXT_TABLE_LOLEN)
]])
m4_if_c_only([[
m4_dnl This echo is needed to remove inner quoting of data statements,
m4_dnl which is needed to keep formatting through the C++ patsubst below.
m4_echo(M4_GEN_DATA_TABLES)
]],[[
m4_dnl Add C++ class prefix to all yy* names, and remove 'static'.
m4_bpatsubsts(m4_quote(M4_GEN_DATA_TABLES),
[[\byy]],[[M4_YY_CLASS::yy]],
[[static ]],[[]])
]])

/****************** Define functions *****************/
#ifdef YY_INPUT_INLINE
M4_FUNC_DEF(inline int, yy_input, char* buf, int max_size)
{
	int result;
M4_YY_INPUT()
	return result;
}
#endif
[[
%% USER BOTTOM CODE -- %bottom{ ... %}
]]M4_LINE_DIRECTIVE()

/**********************************************************************/
m4_dnl  All other functions are in "flex_functions.m4". This one needs
m4_dnl  to be in the main file because it contains %% code insertion marks.
/* The main scanner function which does all the work.
 * A #define so the user can easily add parameters.
m4_if_reentrant([[m4_dnl
 * If YY_DECL is defined in the reentrant scanner, and includes yylval
 * and/or yylloc parameters, #define YY_LVAL_PARAM and YY_LLOC_PARAM to
 * the parameter names. Alternatively, leave out those parameters, and
 * set them via yyset_lval() and yyset_lloc().
]])m4_dnl
 */
/* FIXME: SHouldn't at_bol already be valid? If not, what if yyleng==0?  (JMK) */
m4_dnl yycolumn probably needs:   yycolumn += yyleng
m4_ifdef( [[M4_YY_BOL_NEEDED]],
[[
#define YY_RULE_SETUP \
	if ( yyleng > 0 ) \
		YY_CURRENT_BUFFER->at_bol = (yytext[yyleng - 1] == '\n'); \
	YY_USER_ACTION
]],
[[
#define YY_RULE_SETUP YY_USER_ACTION
]])

m4_ifdef( [[M4_YY_BISON_LVAL]],[[
#ifndef YY_LVAL_PARAM
#define YY_LVAL_PARAM yylval
#endif
]])
m4_ifdef( [[M4_YY_BISON_LLOC]],[[
#ifndef YY_LLOC_PARAM
#define YY_LLOC_PARAM yylloc
#endif
]])
#ifdef YY_DECL
m4_if_cxx_only([[M4_YY_CLASS::]])m4_dnl
YY_DECL
#else
m4_ifdef( [[M4_YY_BISON_LLOC]],[[m4_dnl
M4_FUNC_DEF(int, yylex, YYSTYPE *yylval, YYLTYPE *yylloc)
]],[[m4_dnl
    m4_ifdef( [[M4_YY_BISON_LVAL]],[[m4_dnl
M4_FUNC_DEF(int, yylex, YYSTYPE *yylval)
    ]],[[m4_dnl
M4_FUNC_DEF(int, yylex)
    ]])m4_dnl
]])m4_dnl
#endif
{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;

m4_if_reentrant([[
    m4_ifdef( [[M4_YY_BISON_LVAL]],
    [[
#ifdef YY_LVAL_PARAM
	((struct yyobject_t*)yyscanner)->lval = YY_LVAL_PARAM;
#define yylval ((struct yyobject_t*)yyscanner)->lval
#endif
    ]])
    m4_ifdef( [[M4_YY_BISON_LLOC]],
    [[
#ifdef YY_LVAL_PARAM
	((struct yyobject_t*)yyscanner)->lloc = YY_LLOC_PARAM;
#define yylloc ((struct yyobject_t*)yyscanner)->lloc
#endif
    ]])
]])
m4_ifdef([[M4_M4_RENAME_MACROS]],m4_echo(M4_M4_RENAME_MACROS()))[[]]m4_dnl
m4_if_tables_serialization([[m4_dnl JMK: added this safety check.
	if (yydmap[0].dm_arr && ! *(yydmap[0].dm_arr) ) YY_FATAL_ERROR(
		"fatal flex scanner error -- Serialized tables were not loaded" );
]])

[[
%% USER DECLARATIONS (input section 2)
]]M4_LINE_DIRECTIVE()
	if ( ! (yy_init & YYLEX_INIT_USER) )
	{
#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif
		/* If user-init is done, state init has to be done, so
		 * we avoid an extra conditional for every yylex() call.
		 */
		yy_init |= YYLEX_INIT_USER;
		yylex_init_state();
	}

	while ( 1 )		/* loops until end-of-file is reached */
	{
m4_ifdef( [[M4_YY_USES_YYMORE]],
[[
    m4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],,
    [[
		yy_more_len = 0;
		if ( yy_more_flag )
		{
			yy_more_len = yy_c_buf_p - yytext_ptr;
			yy_more_flag = 0;
		}
    ]])
]])
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

M4_GEN_START_STATE()

yy_match:
M4_GEN_NEXT_MATCH()

yy_find_action:
M4_GEN_FIND_ACTION_NUMBER()

		YY_DO_BEFORE_ACTION;

m4_ifdef( [[M4_YY_USE_LINENO]],
[[
	if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
	{
		int yyl;
		for ( yyl = m4_dnl
    m4_ifdef( [[M4_YY_USES_YYMORE]],[[m4_dnl
	m4_ifdef( [[M4_YYTEXT_IS_ARRAY]],m4_dnl
	[[yy_prev_more_offset]],m4_dnl
	[[yy_more_len]])m4_dnl
    ]],[[m4_dnl
	[[0]]m4_dnl
    ]]); yyl < yyleng; ++yyl)
			if ( yytext[yyl] == '\n' )
				M4_YY_INCR_LINENO();
	}
]])

do_action:	/* This label is used only to access EOF actions. */

m4_dnl NOTE: This is the only place using print functions, instead of ERROR macros.
m4_ifdef( [[M4_FLEX_DEBUG]],
[[
	if ( yy_flex_debug )
	{
    m4_if_cxx_streamio([[
		if ( yy_act == 0 )
			std::cerr << YY_("--scanner backing up\n");
		else if ( yy_act < YY_NUM_RULES )
			std::cerr << YY_("--accepting rule at line ")
				<< yy_rule_linenum[yy_act]
				<< "(\"" << yytext << "\")\n";
		else if ( yy_act == YY_NUM_RULES )
			std::cerr << YY_("--accepting default rule ")
        			<< "(\"" << yytext << "\")\n");
		else if ( yy_act == (YY_NUM_RULES + 1) )
			std::cerr << YY_("--(end of buffer or a NUL)\n");
		else
			std::cerr << YY_("--EOF (start condition ")
				<< YY_START << ")\n";
    ]],
    [[
/* Some of these C messages are split up so that they will have
 * the same text strings as messages written using C++ iostream.
 */
		if ( yy_act == 0 )
			fprintf( stderr, YY_("--scanner backing up\n"));
		else if ( yy_act < YY_NUM_RULES )
			fprintf( stderr, "%s%ld(\"%s\")\n",
					YY_("--accepting rule at line "),
					(long)yy_rule_linenum[yy_act], yytext );
		else if ( yy_act == YY_NUM_RULES )
			fprintf( stderr, "%s(\"%s\")\n",
					YY_("--accepting default rule "), yytext );
		else if ( yy_act == (YY_NUM_RULES + 1) )
			fprintf( stderr, YY_("--(end of buffer or a NUL)\n") );
		else
			fprintf( stderr, "%s%d)\n",
					YY_("--EOF (start condition "), YY_START );
    ]])
	}
]])

	switch( yy_act )
	{ /* beginning of action switch */
m4_ifdef([[M4_YY_NEED_BACKING_UP]],[[
	case 0: /* must back up */
	/* undo the effects of YY_DO_BEFORE_ACTION */
	*yy_cp = yy_hold_char;

    m4_ifdef([[M4_YY_COMPRESSED]],[[
	/* Backing-up info for compressed tables is taken *after*
	 * yy_cp has been incremented for the next state.
	 */
	yy_cp = yy_last_accepting_cpos;
    ]],[[
	yy_cp = yy_last_accepting_cpos + 1;
    ]])

	yy_current_state = yy_last_accepting_state;
	goto yy_find_action;
]])

m4_dnl This section also contains user code, and must be quoted.
m4_dnl If m4 processing is wanted for the generated parts, the
m4_dnl generated code could be made to internally quote just the
m4_dnl user action code, and leave generated code exposed to m4.
[[
%% GEN ACTIONS
]]M4_LINE_DIRECTIVE()

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER->buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action(other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = YY_CURRENT_BUFFER->n_chars;
			YY_CURRENT_BUFFER->input_file = yyin;
			YY_CURRENT_BUFFER->buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &YY_CURRENT_BUFFER->ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming(and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state);

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
m4_dnl %% [14.0] code to do back-up for compressed tables and set up yy_cp goes here
m4_dnl	/* First, deal with backing up and setting up yy_cp if the scanner
m4_dnl	 * finds that it should JAM on the NUL.
m4_dnl	 */
m4_ifdef([[M4_YY_COMPRESSED]],[[
    m4_if(!m4_defined([[M4_YY_USES_REJECT]]) && !m4_defined([[M4_YY_INTERACTIVE]]),[[
m4_dnl			/* Do the guaranteed-needed backing up to figure
m4_dnl			 * out the match.
m4_dnl			 */
				yy_cp = yy_last_accepting_cpos;
				yy_current_state = yy_last_accepting_state;
    ]],
    [[
m4_dnl			/* Still need to initialize yy_cp, though
m4_dnl			 * yy_current_state was set up by
m4_dnl			 * yy_get_previous_state().
m4_dnl			 */
				yy_cp = yy_c_buf_p;
    ]])
]],
[[
				yy_cp = yy_c_buf_p;
]])

				goto yy_find_action;
				}
			}

		else switch( yy_get_next_buffer( ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap( ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser(like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( );

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&YY_CURRENT_BUFFER->ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state( );

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			YY_("fatal flex scanner internal error--no action found"));
	} /* end of action switch */
	} /* end of scanning one token */
} /* end of yylex */

m4_flex_include([[flex_functions.m4]])

m4_ifdef([[M4_YY_NAMESPACE]],[[
} /* end namespace M4_YY_NAMESPACE() */
]])
/*********************************************************/
/* Redefine yyless() so it works in section 3 user code. */
#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
	int yyless_macro_arg = (n); \
	YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yy_hold_char; \
		yy_c_buf_p = yytext + yyless_macro_arg; \
		yy_hold_char = *yy_c_buf_p; \
		*yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

[[
%% USER CODE SECTION 3
]]M4_LINE_DIRECTIVE()

