
#ifndef testFLEX_HEADER_H
#define testFLEX_HEADER_H
#define testIN_HEADER 1

/* A lexical scanner generated by flex */

M4_LINE_DIRECTIVE()

/* begin standard C headers. */
m4_if_cxx_streamio(,
#include <stdio.h>
)
m4_if_c_only(
#include <string.h>
#include <stdlib.h>
,

#include <stdlib.h> /* C memory allocation is used in the C++ class */
)
#include <errno.h>
m4_if_tables_serialization(
/* These are for ntohs() and ntohl(), used for serialized tables: */
#include <sys/types.h>
#include <netinet/in.h>
)
/* end standard C headers. */

/* begin standard C++ headers. */
m4_if_cxx_streamio(
#include <iostream>
,

    m4_if_cxx_only([[
#include <cstdio>
    ]])
)
m4_if_cxx_only(
#include <cstring>
#include <cstdlib>
)
/* end standard C++ headers. */

/* begin "flexint.h" */
m4_flex_include(flexint.h)
/* end "flexint.h" */

m4_if_c_only(
m4_ifdef([[M4_YY_NAMESPACE]],[[
namespace M4_YY_NAMESPACE() {
]])
m4_flex_include([[flex_public_header.m4]])
m4_ifdef([[M4_YY_NO_EXTERN_C]],,[[
#ifdef __cplusplus
extern "C" {
#endif
]])
m4_flex_include([[flex_public_typedefs.m4]])
m4_if_not_reentrant([[
/************************************************************/
/* Declaration of public globals */
M4_PUBLIC_GLOBALS()
]])
m4_flex_include([[flex_public_protos.m4]])
m4_ifdef([[M4_YY_NO_EXTERN_C]],,[[
#ifdef __cplusplus
} /* end extern "C" */
#endif
]])
m4_ifdef([[M4_YY_NAMESPACE]],[[
} /* end namespace M4_YY_NAMESPACE() */
]])
,

/************************************************************/
/* These defines prevent inclusion of the previous "FlexLexer.h" by user code. */
#define yyFlexLexerOnce
#define __FLEX_LEXER_H

#ifndef YYLEX_BASE_CLASS_DEFINED
#define YYLEX_BASE_CLASS_DEFINED

m4_flex_include([[flex_public_header.m4]])

/* pure-virtual base class */
class M4_YY_LEX_BASE_CLASS {
public:
m4_flex_include([[flex_public_typedefs.m4]])

protected: /*FIXME protected: */
m4_flex_include([[flex_private_typedefs.m4]])

public:
/* Note: no destructor defined */
	virtual ~M4_YY_LEX_BASE_CLASS()(void) { };

	virtual void switch_to_buffer(YY_BUFFER_STATE new_buffer ) = 0;
	virtual YY_BUFFER_STATE create_buffer(M4_INSTREAM* stream, int size ) = 0;
	virtual void delete_buffer(YY_BUFFER_STATE buffer ) = 0;
	virtual void restart(M4_INSTREAM* stream ) = 0;
	virtual int lex(void) = 0;

	// NOTE: In Flex, yytext is allowed to be modified in scanner actions.
	// This version allows read-only access for general use with the base class.
	inline const char* YYText(void) { return text; }
	inline int YYLeng(void) { return leng; }
	//inline int lineno() const { return yylineno; }
	inline int debug() const { return flex_debug; }
	inline void debug( int flag ) { flex_debug = flag; }

	// Call yylex with new input/output sources.
	inline int lex(M4_INSTREAM* new_in, M4_OUTSTREAM* new_out = NULL )
	{
		switch_streams( new_in, new_out );
		return lex();
	}

	// Switch to new input/output streams. If NULL, the stream is unchanged.
	virtual void switch_streams( M4_INSTREAM* new_in = NULL,
					M4_OUTSTREAM* new_out = NULL ) = 0;

	/************ Common state variables ************/
// These are equivalent to the public globals in the non-reentrant C scanner.

protected:

M4_PUBLIC_GLOBALS()

}; /* end M4_YY_LEX_BASE_CLASS */
#endif // YYLEX_BASE_CLASS_DEFINED

#define yyFlexLexer M4_YY_LEX_CLASS()

class M4_YY_LEX_CLASS() : public M4_YY_LEX_BASE_CLASS {
public:
m4_ifdef( [[M4_YY_NO_EXTRA]],,
[[
	/* User-defined. Not touched by flex. */
	YY_EXTRA_TYPE extra;
]])

	M4_YY_LEX_CLASS()
		(M4_INSTREAM* arg_yyin = M4_STDIN,
		 M4_OUTSTREAM* arg_yyout = M4_STDOUT);

	~M4_YY_LEX_CLASS()(void);

// C++ subclasses must have the standard lex(void) function to
// support the base class. YY_DECL may still be used to alter the
// yy[[]]lex function constructed by flex, but you then must
// provide a body for the default lex() function.
// For Bison lloc and lval, use set_lval() and set_lloc().
	int lex(void);
#ifdef YY_DECL
        YY_DECL;
#endif

m4_ifdef( [[M4_YY_SKIP_YYWRAP]],
[[
	inline int yywrap(void) const { return 1; };
]])

// Declarations for additional C++-only functions.

/* Standard YY_INPUT() */
	int LexerInput( char* buf, int max_size );

/* Standard ECHO() */
	inline int LexerOutput( const char* buf, int size )
	{
m4_if_cxx_streamio([[
/* With an error, iostream does not expose the number of bytes written,
 * so it is estimated as all-or-nothing. (Good enough for error tests.)
 */
		out->write( buf, size );
		return (out->bad() ? 0 : size);
]],
[[
		return fwrite( buf, 1, size, out );
]])
	}

	virtual void LexerError( const char* msg ) { LexerClassError(msg); }

	void switch_streams(M4_INSTREAM* new_in, M4_OUTSTREAM* new_out=0);

public:
m4_define([[yy_flex_strlen]],[[strlen]])
M4_FUNC_PROTO_NG(void, LexerClassError, const char *msg);
m4_flex_include([[flex_public_protos.m4]])

private:
M4_PRIVATE_GLOBALS()

private:
m4_dnl This strips the assignments, to give just declarations.
m4_patsubst(m4_quote(M4_GEN_DATA_TABLES),[[\s*=[^;]*;]],[[;]])

private:
m4_flex_include([[flex_private_protos.m4]])

/* This allows the class to be modified without an additional sub-class */
#ifdef YY_CLASS_USER_CODE
YY_CLASS_USER_CODE
#endif
}; /* end M4_YY_LEX_CLASS */
)

#undef testIN_HEADER
#endif /* testFLEX_HEADER_H */
