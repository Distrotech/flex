
#ifndef testFLEX_HEADER_H
#define testFLEX_HEADER_H
#define testIN_HEADER 1

/* A lexical scanner generated by flex */

#line 40 "scanner.l"
#define DEFINE_ME "hello{"


#line 13 "scanner.h"

/* begin standard C headers. */

#include <stdio.h>

#include <string.h>
#include <stdlib.h>

#include <errno.h>

/* end standard C headers. */

/* begin standard C++ headers. */

/* end standard C++ headers. */

/* begin "flexint.h" */
/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;
#endif /* ! C99 */

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! FLEXINT_H */

/* end "flexint.h" */

/************************************************************/
/* Public CPP definitions */

#define YY_INT_ALIGNED flex_int16_t

#define YYIN_INIT ((FILE *)0)
#define YYOUT_INIT ((FILE *)0)

#define FLEX_SCANNER

#define YY_FLEX_VERSION 2.5.35

#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 35

#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef YY_HEADER_EXPORT_START_CONDITIONS
#define YY_START_CONDITIONS_DEFINED
#define INITIAL 0

#endif

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE 16384
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* FIXME: move these to the private header? */
/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO

/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite(). Checking for successful output is new.
 */
#define ECHO if ( fwrite(yytext, yyleng, 1, yyout) != yyleng) \
		{ YY_FATAL_ERROR( "output in flex scanner failed" ); }

#endif

/* YY_INPUT Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT

#ifdef YY_INPUT_INLINE
/* Note: yy_input() is not the same as yyinput(). */
#define YY_INPUT(buf,result,max_size) result = yy_input(buf,max_size)
#else
#define YY_INPUT(buf,result,max_size) \
if ( YY_CURRENT_BUFFER->is_interactive ) \
		{ \
		int c = '*'; \
		int n; \
		for( n = 0; n < (int)max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
			{ \
			if ( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		} \
    
#endif

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

#ifndef YY_ISATTY

#define YY_ISATTY(file) (file ? (isatty(fileno(file)) > 0) : 0)

#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR

#define YY_FATAL_ERROR(msg) yy_fatal_error(msg, yyscanner)

#endif

/* The exit() code for fatal errors. */
#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

/* Report a non-fatal error. (experimental) */
#ifndef YY_NONFATAL_ERROR
#define YY_NONFATAL_ERROR YY_FATAL_ERROR
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#ifdef __cplusplus
extern "C" {
#endif

/************************************************************/
/* Public Typedefs */

/* An opaque pointer. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *input_file;

	char *ch_buf;		/* input buffer */
	char *buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int at_bol;

	int bs_lineno; /**< The line count. */
	int bs_column; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int fill_buffer;

	/* Buffer status #defines are currently not written to the
	 * public header.
	 */
	int buffer_status;

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

/*******************************************************************/
/* Declaration of public functions */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
    extern int testlex(yyscan_t yyscanner);
    #endif

extern void testrestart(FILE *input_file,yyscan_t yyscanner);
extern void test_switch_to_buffer(YY_BUFFER_STATE new_buffer,yyscan_t yyscanner);
extern YY_BUFFER_STATE test_create_buffer(FILE *file,int size ,yyscan_t yyscanner);
extern void test_delete_buffer(YY_BUFFER_STATE b,yyscan_t yyscanner);
extern void test_flush_buffer(YY_BUFFER_STATE b,yyscan_t yyscanner);
extern void testpush_buffer_state(YY_BUFFER_STATE new_buffer,yyscan_t yyscanner);
extern void testpop_buffer_state(yyscan_t yyscanner);

extern void * testalloc(yy_size_t size,yyscan_t yyscanner);
extern void * testrealloc(void *ptr,yy_size_t size,yyscan_t yyscanner);
extern void testfree(void *ptr,yyscan_t yyscanner);

extern YY_BUFFER_STATE test_scan_buffer(char *base,yy_size_t size,yyscan_t yyscanner);
extern YY_BUFFER_STATE test_scan_string(const char *yy_str,yyscan_t yyscanner);
extern YY_BUFFER_STATE test_scan_bytes(const char *bytes,int len,yyscan_t yyscanner);

/* Constructors for the C reentrant scanner. The destructor is
 * yylex_destroy(), which is also used to release the non-reentrant scanner.
 */
extern int testlex_init(yyscan_t *yyscanner_return);

extern int testlex_init_extra(YY_EXTRA_TYPE user_defined,yyscan_t *yyscanner_return);

extern void testlex_init_state(yyscan_t yyscanner);

/*******************************************************************/
/* Accessor methods to globals.
 * These are made visible to non-reentrant scanners for convenience.
 * A nice feature would be an option to make these inline functions.
 */

extern int testlex_destroy(yyscan_t yyscanner);

extern int testget_debug(const yyscan_t yyscanner);

extern void testset_debug(int debug_flag,yyscan_t yyscanner);

extern YY_EXTRA_TYPE testget_extra(const yyscan_t yyscanner);

extern void testset_extra(YY_EXTRA_TYPE user_defined,yyscan_t yyscanner);

extern FILE * testget_in(const yyscan_t yyscanner);

extern void testset_in(FILE *in_str,yyscan_t yyscanner);

extern FILE * testget_out(const yyscan_t yyscanner);

extern void testset_out(FILE *out_str,yyscan_t yyscanner);

extern int testget_leng(const yyscan_t yyscanner);

extern char * testget_text(const yyscan_t yyscanner);

extern int testget_lineno(const yyscan_t yyscanner);

extern void testset_lineno(int line_number,yyscan_t yyscanner);

extern int testget_column(const yyscan_t yyscanner);

extern void testset_column(int column_no,yyscan_t yyscanner);

#ifdef __cplusplus
} /* end extern "C" */
#endif

#undef testIN_HEADER
#endif /* testFLEX_HEADER_H */
